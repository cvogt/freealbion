<?xml version="1.0" encoding="UTF-8"?>
<a2e_shader version="1">
	<includes>gbuffer</includes>
	
	<vertex_shader>
		<variables>
			uniform vec3 cam_position;
			uniform vec3 model_position;
			uniform mat4 local_mview;
			uniform mat4 local_scale;
			
			attribute vec3 normal;
			attribute vec2 texture_coord;
			attribute vec3 binormal;
			attribute vec3 tangent;
			
			varying vec3 out_normal;
			varying vec2 out_tex_coord;
			varying vec3 out_view_vec;
		</variables>
		<program>
void main() {
			mat4 transform_mat = local_scale * local_mview;
			
			out_tex_coord = texture_coord;
			
			vec3 tvertex = vec3(transform_mat * gl_Vertex);
			vec3 vview = cam_position - model_position - tvertex;

			vec3 vv_tangent = vec3(transform_mat * vec4(tangent, 1.0));
			vec3 vv_binormal = vec3(transform_mat * vec4(binormal, 1.0));
			vec3 vv_normal = vec3(transform_mat * vec4(normal, 1.0));

			out_view_vec.x = dot(vview, vv_tangent);  // s tangent
			out_view_vec.y = dot(vview, vv_binormal); // t tangent
			out_view_vec.z = dot(vview, vv_normal);   // normal
			
			gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}
		</program>
	</vertex_shader>
	
	<fragment_shader>
		<variables>
			uniform sampler2D diffuse_texture;
			uniform sampler2D specular_texture;
			uniform sampler2D height_texture;
			uniform sampler2D normal_texture;
			uniform vec2 Nuv;
			uniform float max_step_count;
			
			varying vec3 out_normal;
			varying vec2 out_tex_coord;
			varying vec3 out_view_vec;
		</variables>
		<program>
void main() {
			//
			vec3 view_vec = normalize(out_view_vec);
			
			vec3 parallax_tex_coord = vec3(out_tex_coord, 1.0);
			
			//float steps = max_step_count * length(view_vec.xy);
			float steps = mix(max_step_count, 32.0, length(view_vec.xy));
			
			vec3 dir = view_vec;
			dir.xy /= 24.0;
			dir /= -steps * dir.z;
			
			float diff0;
			float diff1 = 1.0 - texture2DLod(height_texture, parallax_tex_coord.xy, 0.0).x; // texCoord.z = 1.0 initially
			if(diff1 > 0.0) {
				do {
					parallax_tex_coord += dir;
			
					diff0 = diff1;
					diff1 = parallax_tex_coord.z - texture2DLod(height_texture, parallax_tex_coord.xy, 0.0).x;
				} while(diff1 > 0.0);
			
				parallax_tex_coord.xy += (diff1 / (diff0 - diff1)) * dir.xy;
			}
			
			// lookup diffuse, normal and specular texture color (with transformed (parallax) tex coord)
			vec4 diffuse_color = texture2D(diffuse_texture, parallax_tex_coord.xy);
			vec4 specular_color = texture2D(specular_texture, parallax_tex_coord.xy);
			vec3 normal = texture2D(normal_texture, parallax_tex_coord.xy).xyz * 2.0 - 1.0;
			
			// write to gbuffer
			write_gbuffer(diffuse_color, specular_color, normal, Nuv);
}
		</program>
	</fragment_shader>

</a2e_shader>