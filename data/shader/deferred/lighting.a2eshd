<?xml version="1.0" encoding="UTF-8"?>
<a2e_shader version="1">
	<vertex_shader version="120">
		<variables>
			uniform vec3 light_position;
			
			uniform mat4 PM;
			uniform mat4 MVM;
		</variables>
		<program>
void main() {
			gl_Position = (PM * MVM) * (gl_Vertex + vec4(light_position, 0.0));
}
		</program>
	</vertex_shader>
	
	<fragment_shader version="120">
		<variables>
			uniform sampler2D rt0;
			uniform sampler2D rt1;
			uniform sampler2D rt2;
			uniform sampler2D depth_buffer;
			
			uniform vec3 cam_position;
			uniform vec2 screen_size;
			uniform vec2 projection_ab;
			
			uniform vec3 light_position;
			uniform vec3 light_ambient;
			uniform vec3 light_diffuse;
			uniform vec3 light_specular;
			uniform vec3 light_attenuation;
			
			uniform mat4 IMVM;
		</variables>
		<program>
void main() {
			vec2 tex_coord = gl_FragCoord.xy / screen_size;
			//float coeff = (mod(floor(tex_coord.x / (1.0/8.0)), 2.0) >= 1.0) ? 0.0 : 1.0;
			
			float depth = texture2D(depth_buffer, tex_coord).r; // in [0, 1]
			if(depth >= 1.0) discard;
			
			vec4 diff_color = texture2D(rt0, tex_coord);
			vec4 spec_color = texture2D(rt1, tex_coord);
			vec4 normal_nuv = texture2D(rt2, tex_coord);
			
			////////////////////////////////////////////////////////////////////////////
			// reconstruct world space position
			float linear_depth = projection_ab.y / (depth - projection_ab.x); // in [near plane, far plane]
			const float up_vec = 0.72654252800536066024136247722454;
			float right_vec = 0.72654252800536066024136247722454 * (screen_size.x / screen_size.y);

			vec3 rep_pos;
			rep_pos.z = -linear_depth;
			rep_pos.xy = (tex_coord * 2.0 - 1.0) * vec2(right_vec, up_vec) * linear_depth;
			rep_pos = vec3(IMVM * vec4(rep_pos, 1.0));
	
			
			////////////////////////////////////////////////////////////////////////////
			// decode normal
			vec3 normal;
			normal.z = dot(normal_nuv.xy, normal_nuv.xy) * 2.0 - 1.0;
			// and again: abs inner sqrt result, b/c of fp inaccuracies
			normal.xy = normalize(normal_nuv.xy) * sqrt(abs(1.0 - normal.z * normal.z));
			
			
			////////////////////////////////////////////////////////////////////////////
			// lighting
			vec3 final_color = vec3(0.0);
			vec3 light_dir = light_position - rep_pos;
			vec3 view_dir = cam_position - rep_pos;
			
			float dist = length(light_dir);
			float attenuation = max(1.0 / (light_attenuation.x + (light_attenuation.y * dist) + (light_attenuation.z * dist * dist)), 0.0);
			
			light_dir = normalize(light_dir);
			view_dir = normalize(view_dir);
			
#if 1
			// phong lighting
			
			vec3 E, R;
			E = view_dir;
			float lambertTerm, specular;
			
			final_color += light_ambient * attenuation;
			
			lambertTerm = dot(normal, light_dir);
			if(lambertTerm > 0.0) {
				final_color += light_diffuse * lambertTerm * attenuation;
			
				R = reflect(-light_dir, normal);
				specular = pow(max(dot(R, E), 0.0), 16.0f);
			
				final_color += light_specular * specular * spec_color.rgb * attenuation;
			}
			final_color = diff_color.rgb * final_color;
#else
			// ashikhmin/shirley lighting
			
			// setup vars
			float Nu = normal_nuv.z;
			float Nv = normal_nuv.w;
			//spec_color *= 0.1;
			vec3 Nf = normalize(normal);
			vec3 Vf = normalize(view_dir);
			float NdotV = dot(Nf, Vf);
			
			//
			vec3 epsilon = vec3( 1.0, 0.0, 0.0 );
			vec3 tangent = normalize( cross( Nf, epsilon ) );
			vec3 bitangent = normalize( cross( Nf, tangent ) );
			
			//
			vec3 ambient = vec3(0.0);
			vec3 diffuse = vec3(0.0);
			vec3 specular = vec3(0.0);
			vec3 L, H, Pd, Ps;
			float NdotH, BdotH, TdotH, LdotH, NdotL;
			float ps_num_exp, Ps_num, Ps_den;
			
			ambient += light_ambient * attenuation;
			
			spec_color *= 0.5; // scale down specular
			
			L = light_dir;
			NdotL = dot(Nf, L);
			if(NdotL > 0.0) {
				Pd = (28.0 * diff_color.rgb * light_diffuse) / ( 23.0 * 3.14159265 );
				Pd *= vec3(1.0) - spec_color.rgb * 0.02 * light_specular; // scale down specular a bit more
				Pd *= (1.0 - pow(1.0 - (NdotL / 2.0), 5.0));
				Pd *= (1.0 - pow(1.0 - (NdotV / 2.0), 5.0));
				Pd *= attenuation;
				diffuse += Pd;
			
				if(NdotV > 0.0) {
					H = normalize(L + Vf);
					NdotH = dot(Nf, H);
					BdotH = dot(bitangent, H);
					TdotH = dot(tangent, H);
					LdotH = dot(L, H);
			
					ps_num_exp = Nu * TdotH * TdotH + Nv * BdotH * BdotH;
					ps_num_exp /= 1.0 - NdotH * NdotH;
			
					Ps_num = sqrt( (Nu + 1.0) * (Nv + 1.0) );
					Ps_num *= pow( NdotH, ps_num_exp );
			
					Ps_den = 8.0 * 3.14159265 * LdotH;
					Ps_den *= max( NdotL, NdotV );
			
					Ps = spec_color.rgb * (Ps_num / Ps_den);
					Ps *= spec_color.rgb + (vec3(1.0) - spec_color.rgb * light_specular) * pow( 1.0 - LdotH, 5.0 );
					Ps *= attenuation;
					specular += Ps;
				}
			}
			
			final_color = ambient + diffuse + specular;
#endif
			gl_FragColor = vec4(final_color, 1.0);
}
		</program>
	</fragment_shader>
	
</a2e_shader>